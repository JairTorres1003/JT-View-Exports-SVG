# 🧩 VSCode Extension Dev Server

This directory contains the **development server** for the VSCode extension "**View Exports SVG**".

Its main purpose is to enable a **faster development workflow** between the **extension (ESM build)** and the **WebView UI client**, without having to rebuild and reload the entire extension every time a change is made.

---

## 🚀 Purpose

The goal of this server is to provide a **lightweight Deno-based environment** that runs a **compiled ESM version** of the extension.

This setup allows both the backend (extension logic) and the frontend (WebView) to interact instantly, eliminating the slow and repetitive steps of:

1. Rebuilding the entire extension.
2. Reloading the VSCode Extension Host.
3. Waiting for the environment to start again.

---

## ⚙️ Development workflow

1. From the **project root**, generate the ESM build of the extension using one of the following commands:

   ```bash
   # Static build (no watcher)
   npm run compile:esm

   # Watch mode (auto-rebuild on changes)
   npm run watch:esm
   ```

   > ⚠️ Both commands must be run from the project root, not inside the `server` folder.

2. The generated build is **not a stable or production-ready version** — it only exposes the extension’s functionality so it can be used and tested within the development server.

---

## 🧱 Server structure

```bash
server
├── .env.example
├── deno.json
└── src
    ├── app.ts
    ├── controllers
    ├── libs
    ├── mocks
    ├── polyfill.ts
    ├── routes
    ├── server.ts
    ├── types.d.ts
    ├── utilities
    ├── views
    └── vscode.ts
```

---

## 🧩 ESM build integration

The build generated by **compile:esm** or **watch:esm** is imported directly by the Deno server through path aliases defined in **deno.json**:

```json
"@jt/view-exports-svg/": "../out/esm/",
"@jt/view-exports-svg/package": "../package.json"
```

However, the build **does not work standalone**, since it depends on VSCode APIs.
To resolve those, the following package is used:

```bash
@codingame/monaco-vscode-api
```

This library provides **partial implementations** of the VSCode API, allowing ESM builds to run and behave similarly to the real extension environment.

Additional mock packages are also included to emulate system or browser features unavailable in the generated build.

---

## 🌐 Client–server communication

Communication between the WebView client and the Deno server is handled via Express routes, which act as equivalent endpoints for `postMessage` events from the VSCode API.

- Each route file (`*.routes.ts`) defines endpoints for a specific feature (files, icons, SVGs, etc.).
- Each controller (`*.controller.ts`) processes the request, calls the related ESM function, and returns a typed response:

```ts
{
  type: string // message type or key
  data: any // response payload
}
```

This keeps the data flow identical to how VSCode’s internal messaging works between the WebView and the extension host.

---

## 🧠 Using the server as an API

The development server can also run standalone and be used as an API:

```bash
http://localhost:3000/api/{path}
```

This is useful for testing endpoints directly through a browser or tools like Postman, without launching the client UI.

---

## 🖥️ Connecting the client (WebView UI)

From the project root:

```bash
cd client
npm run dev:vite   # Fast mode (recommended)
# or
npm run dev        # Standard mode (uses Webpack)
```

### Differences

- **Vite**: enables faster pre-bundling and hot reload → ideal for rapid iterations.
- **Webpack**: performs full rebuilds → closer to the actual VSCode WebView runtime.

---

## 🔌 Simulating the VSCode API

During local development, the client cannot access the real VSCode API (`vscode.postMessage`, `vscode.getState`, etc.).

To overcome this, a simulation layer called `vscodeInternal` is implemented at:”

```bash
client/src/services/vscode/index.ts
```

This class:

1. Extends and mimics key VSCode API methods.
2. Replaces `postMessage` calls with HTTP `GET`/`POST` requests made via **Axios** to the Deno server.
3. Upon receiving a response, it uses `window.postMessage` to emulate a VSCode-like message response.

---

## 🧪 Summary

| Purpose                   | Tool / File                                 |
| ------------------------- | ------------------------------------------- |
| Generate ESM build        | `npm run compile:esm` / `npm run watch:esm` |
| Development server        | `server/src/server.ts`                      |
| Message routing           | Express routes & controllers                |
| VSCode API simulation     | `vscodeInternal`                            |
| Fast WebView client build | `npm run dev:vite`                          |

---

## 📋 Notes

- This setup is **not meant to replace** running the extension inside VSCode.
- It exists purely for **faster development and debugging**.
- The ESM build is **not production-ready** and should never be published.
